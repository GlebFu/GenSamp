---
title: "Summary"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, cache = F, warnings = F)
```

```{r load.packages, include = FALSE}
library(papaja)
library(tidyverse)

rm(list = ls())

runtimeFile <- "Data/2018-07-11/runtime r1000.rdata"
resultsFile <- "Data/2018-07-11/results r1000.rdata"

load("data/base data.rdata")

# Base data set
load("Data/simData.Rdata")

# Response generating variables and goal SMD
load("Data/RGM Vars.Rdata")

load(runtimeFile)
load(resultsFile)

df_Bindex <- df_Bindex %>%
  mutate(Rank = str_replace(sample, "SUBS_", ""),
         Clustering = ifelse(str_detect(sample, "SUBS"), "SUBS", "None"),
         Clustering = str_replace(Clustering, "F", "DIST"))

df_counts <- df_counts %>%
  mutate(Rank = str_replace(sample, "SUBS_", ""),
         Clustering = ifelse(str_detect(sample, "SUBS"), "SUBS", "None"),
         Clustering = str_replace(Clustering, "F", "DIST"))

df_responses <- df_responses %>%
  mutate(Rank = str_replace(sample, "SUBS_", ""),
         Clustering = ifelse(str_detect(sample, "SUBS"), "SUBS", "None"),
         Clustering = str_replace(Clustering, "F", "DIST"))
  
df_sch_smd <- df_sch_smd %>%
  mutate(Rank = str_replace(sample, "SUBS_", ""),
         Clustering = ifelse(str_detect(sample, "SUBS"), "SUBS", "None"),
         Clustering = str_replace(Clustering, "F", "DIST"))

savePlot <- F
```

```{r}
boxErrors <- function(x) {
  v <- c(min(x), mean(x) - sd(x), mean(x), mean(x) + sd(x), max(x))
  names(v) <- c("ymin", "lower", "middle", "upper", "ymax")
  v
}

```

# Introduction
The main purpose of this study is to set a groundwork for exploring effectiveness and feasibility of sampling methods in the educational field. Using real population data we compare simple random sampling (SRS), convenience sampling (CS), stratified balanced sampling (SBS), stratified simple random sampling (SSRS), and stratified convenience sampling (SCS). Our findings suggest that SBS and SSRS are extremely difficult to implement at low response rates, but result in highly generalizable samples. SRS and SCS are similar in both feasibility and effectiveness, however, stratification offers other advantages beyond generalizability (transparency). 

We found several limitations in that we lack empricical precident for modeling both researcher behavior in recruiting sites, and site behavior in deciding to participate. This work underlines the importance of further research into answering (1) How do we model convenience smapling? and (2) How do schools and districts devide to participate in studies? We argue that reserachers should allocate more funding towards recruitment given the clear increaes in abilty to generalize a sample. 


# Methods Summary

## Participation Generating Model

o	Take a look at coefficients
ï‚§	Add table comparing CS SMDs


Distribution of propensity scores by response rates
```{r}

df.sch %>% 
  select(PS90:PS10) %>% 
  gather(key = RR, value = PS) %>% 
  ggplot(aes(x = PS)) + 
  geom_histogram() + 
  facet_wrap(~RR) +
  theme_apa()


```

## Sampling Method
Recruitment is performed by rearanging the full list of schools and sampling from the list in order until 60 schools agree to participate. This enables the calculation of the total number of schools contacted for recruitment. Schools are arranged in order of rank, which is regenerated in each iteration. Rank generation depends on the sampling method being simulated. In SRS school ranks are randomly assigned. In CS, schools are sampled without replacement one at a time and assigned consecutive ranks. Sampling is weighed by the propensity to participate so that schools that are more likely to participate are also more likely to be sampled earlier. Stratified versions of these methods first group schools into clusters, then generate ranks within each cluster independantly. Schools are sampled until proportional sampling allocation is satisfied. Finally, in SBS schools are grouped into clusters and then ranked in order using a distance metric. These ranks do not vary across iterations in the same conditions. 

### Simple Random Sampling
1. Schools are randomly ranked. 
2. Schools are approached in order of rank until 60 schools agree to participate.

### Convenience Sampling
1. Schools are ranked by sampling without replacement one school at a time. 
2. Schools with higher propensity to participate are more likely to be ranked higher. 
3. Schools are approached in order of rank until 60 schools agree to participate.

### Stratified Balanced Sampling
1. Schools are grouped by cluster. 
2. Within each cluster, schools are ranked using distance metric. 
3. Schools are approached in order of rank until number of schools as defined by proportional sampling allocation agree to participate.

### Stratified Simple Random Sampling
1. Schools are grouped by cluster. 
2. Within each cluster, schools are randomly ranked. 
3. Schools are approached in order of rank until number of schools as defined by proportional sampling allocation agree to participate.

### Stratified Balanced Sampling
1. Schools are grouped by cluster. 
2. Schools are ranked by sampling without replacement one school at a time. 
3. Schools with higher propensity to participate are more likely to be ranked higher. 
4. Schools are approached in order of rank until number of schools as defined by proportional sampling allocation agree to participate.



## B Index

Conditions where B Index is below .2

```{r}


df_Bindex$sch.RR.f <- ordered(df_Bindex$sch.RR)


# levels(df_Bindex$sch.RR.f) <- paste(c("\n", "School Rate\n", "\n"), levels(df_Bindex$sch.RR.f))

df_Bindex %>% 
  select(sample:Bs) %>% 
  filter(Bs < .2) %>%
  as.tibble() %>%
  group_by(sample, sch.RR) %>%
  summarise(n = n()) %>%
  spread(key = sch.RR, value = n)
```

```{r}
df_Bindex %>%
  filter(Bs > .25) %>%
  ggplot(aes(x = sample, y = Bs, color = Rank, linetype = Clustering)) +
  # stat_summary(fun.data = boxErrors, geom = "boxplot", position = position_dodge(width=1)) +
  geom_boxplot() +
  facet_wrap(~ sch.RR.f) +
  theme_apa(box = T) +
  # scale_fill_brewer(type = "seq", palette = 4, guide=FALSE) +
  # scale_color_brewer(type = "qual", palette = 2)  +
  theme(legend.position = "none",
        panel.spacing = unit(2, "lines"),
        # text = element_text(size=20),
        # legend.title = element_text(size=15),
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Sampling Method", y = "B-Index")
  

```

```{r}

df_Bindex %>%
  group_by(sample, sch.RR, Clustering, Rank) %>%
  summarise(All = mean(Bs),
            Partial = mean(Bs[Bs > .2]),
            All_sd = sd(Bs),
            Partial_sd = sd(Bs[Bs > .2])) %>%
  gather(key = Type, value = Bs, All, Partial, All_sd, Partial_sd) %>%
  mutate(Var = ifelse(str_detect(Type, "sd"), "SD", "M"),
         Type = ifelse(str_detect(Type, "All"), "All", "Partial")) %>%
  spread(key = Var, value = Bs) %>%
  group_by(sample, sch.RR, Type, Clustering, Rank) %>%
  summarise(M = mean(M),
            SD = mean(SD)) %>%
  mutate(LL = M - SD,
         UL = M + SD) %>%
  ggplot(aes(x = sch.RR, y = M, color = Rank, linetype = Clustering)) +
  # stat_summary(fun.data = boxErrors, geom = "boxplot", position = position_dodge(width=1)) +
  geom_line() +
  # geom_errorbar(aes(ymin=LL, ymax=UL), colour="black", width=.1) +
  facet_wrap(~ Type)

if(savePlot) ggsave("Figs/B-Index.jpg", dpi = 1000, width = 11, height = 8.5)
if(savePlot) ggsave("Figs/B-Index.jpg", dpi = 1000, width = 10, height = 4)
```


## Standardized mean differences

```{r}
sSMDplot <- df_sch_smd %>%
  group_by(sample, sch.RR, Variable, Group, variable, Rank, Clustering) %>%
  summarise(value = mean(abs(value), na.rm = F)) %>% 
  spread(key = variable, value = value) %>%
  ungroup()

# levels(sSMDplot$dist.RR) <- paste("District: ", levels(sSMDplot$dist.RR), "%", sep = "")
# levels(sSMDplot$sch.RR) <- paste("School: ", levels(sSMDplot$sch.RR), "%", sep = "")

sSMDplot %>%
  filter(Group == "sampled") %>%
  ggplot(aes(x = sch.RR, y = sim_SMD, color = Rank, linetype = Clustering, group = sample)) +
  geom_point() +
  geom_line() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = .25, linetype = "dashed") +
  facet_wrap( ~ Variable, scales = "free_y") +
  theme_apa(box = T)


```


```{r}
sSMDplot %>%
  filter(Group == "sampled") %>%
  ggplot(aes(x = sample, y = sim_SMD, group = sample, fill = Rank, linetype = Clustering)) +
  geom_boxplot() +
  geom_line() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = .25, linetype = "dashed") +
  # facet_grid(dist.RR ~ sch.RR, scales = "free_y") +
  theme_apa(box = T) +
  # scale_fill_brewer(type = "seq", palette = 4, guide=FALSE) +
  # scale_color_brewer(type = "qual", palette = 5)  +
  theme(legend.position = "none",
        panel.spacing = unit(2, "lines"),
        text = element_text(size=20),
        legend.title = element_text(size=15)) +
  labs(x = "Sampling Method", y = "Absolute SMD")

if(savePlot)  ggsave("Figs/Sch SMDs.jpg", dpi = 1000, width = 11, height = 8.5)
if(savePlot)  ggsave("Figs/Sch SMDs.jpg", dpi = 1000, width = 10, height = 4)
```

## Sampling Difficulty

```{r}
samplot <- df_responses %>%
  filter(is.na(cluster)) %>%
  group_by(sample, sch.RR, variable, Rank, Clustering) %>%
  summarise(value = mean(value)) %>%
  spread(key = variable, value = value)
```


```{r}
samplot %>%
  gather(key = measure, value = value, -sample, -sch.RR, -Rank, -Clustering) %>%
  mutate(level = str_split(measure, "_", simplify = T)[,1],
         measure =  str_split(measure, "_", simplify = T)[,2]) %>%
  filter(level == "sch") %>%
  ggplot(aes(x = sch.RR, y = value, group = sample, color = Rank, linetype = Clustering)) +
  geom_point() +
  geom_line() +
  facet_wrap( ~ measure, scales = "free_y") +
  expand_limits(y=0) +
  theme_apa(box = T)

```


```{r}
df_responses %>%
  filter(is.na(cluster), str_detect(variable, "sch_contacted")) %>%
  ggplot(aes(x = sample, y = value, color = Rank, linetype = Clustering)) +
  stat_summary(fun.data = boxErrors, geom = "boxplot", position = position_dodge(width=1)) +
  facet_wrap( ~ sch.RR, scales = "free_y") +
  theme_apa(box = T) +
  # scale_fill_brewer(type = "seq", palette = 4, guide=FALSE) +
  # scale_color_brewer(type = "qual", palette = 5)  +
  theme(legend.position = "none",
        panel.spacing = unit(2, "lines"),
        # text = element_text(size=20),
        # legend.title = element_text(size=15),
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Sampling Method", y = "Schools Contacted")

```


```{r}
samplot2 <- samplot %>%
  gather(key = measure, value = value, -sample, -sch.RR, -Rank, -Clustering) %>%
  mutate(level = str_split(measure, "_", simplify = T)[,1],
         measure =  str_split(measure, "_", simplify = T)[,2]) %>%
  filter(measure == "contacted") %>%
  mutate(level = ifelse(level == "sch", "Schools", "Districts"))

samplot2 %>%
  ggplot(aes(x = sch.RR, y = value, group = sample, color = Rank, linetype = Clustering)) +
  geom_point() +
  geom_line() +
  facet_wrap( ~ level, scales = "free_y") +
  expand_limits(y=0) +
  theme_apa(box = T) +
  scale_fill_brewer(type = "seq", palette = 4) +
  scale_color_brewer(type = "qual", palette = 3)  +
  theme(legend.position = "bottom",
        panel.spacing = unit(2, "lines"),
        # text = element_text(size=20),
        # legend.title = element_text(size=15),
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "District Rate", y = "Units Contacted")

if(savePlot)  ggsave("Figs/Units Contacted.jpg", dpi = 1000, width = 11, height = 8.5)

```

```{r}
df.rr <- df_responses %>%
  filter(str_detect(variable, "sch_RR"), is.na(cluster)) %>%
  group_by(sample, sch.RR, Rank, Clustering) %>%
  summarise(value = mean(value)) %>%
  rename(RR = sch.RR) %>%
  mutate(Unit = "School")


df.rr %>%
  ggplot(aes(x = RR, y = value, group = sample, color = Rank, linetype = Clustering)) +
  geom_point() +
  geom_line() +
  facet_grid(~ Unit) +
  expand_limits(y = 0) +
  theme_apa(box = T) +
  # scale_fill_brewer(type = "seq", palette = 4) +
  # scale_color_brewer(type = "qual", palette = 3)  +
  theme(legend.position = "bottom",
        panel.spacing = unit(2, "lines"),
        text = element_text(size=20),
        legend.title = element_text(size=15),
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Generating Repsonse Rate", y = "Actual Response Rate") +
  geom_abline(slope = 25, intercept = 1, linetype = "dashed")

